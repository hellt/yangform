{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"yangpath is an XPATH/RESTCONF-styled schema paths exporter with superpowers. The exported paths can be immediately used in your NETCONF/RESTCONF or gNMI applications. XPATH paths $ yangpath export --yang-dir ~/openconfig/public/ \\ --module ~/openconfig/public/release/models/interfaces/openconfig-interfaces.yang [rw] /interfaces/interface[name=*]/config/description string [rw] /interfaces/interface[name=*]/config/enabled boolean [rw] /interfaces/interface[name=*]/config/loopback-mode boolean [rw] /interfaces/interface[name=*]/config/mtu uint16 [rw] /interfaces/interface[name=*]/config/name string [rw] /interfaces/interface[name=*]/config/type identityref->ietf-if:interface-type <SNIPPED> RESTCONF paths $ yangpath export --yang-dir ~/openconfig/public/ \\ --module ~/openconfig/public/release/models/interfaces/openconfig-interfaces.yang --style restconf [rw] /interfaces/interface=name/config/description string [rw] /interfaces/interface=name/config/enabled boolean [rw] /interfaces/interface=name/config/loopback-mode boolean [rw] /interfaces/interface=name/config/mtu uint16 [rw] /interfaces/interface=name/config/name string [rw] /interfaces/interface=name/config/type identityref->ietf-if:interface-type Features # Preserved list keys The exported paths have the list keys present . Knowing the key names makes it very easy to create XPATH/RESTCONF filters targeting a particular node. Readily available for gNMI The exported paths are fully compatible with the gNMI paths, thanks to the keys being present and set to the wildcard * value. RESTCONF-ready With a matter of a single flag value switch yangpath will export the paths in a RESTCONF style . Paste them in Postman and you're good to go! Type information A unique yangpath feature is its ability to provide the type of a given path . Types give additional context when you retrieve the data, but they are of utter importance for edit the configuration operations. Fast Path export with yangpath is quite fast, working with massive models is no longer a problem! User friendly As always, we strive to publish the tools which spark joy, therefore pre-built images with an effortless installation and a beautiful and extensive documentation comes included. Quick Start # Install # Use the following installation script to install the latest version. sudo curl -sL https://github.com/hellt/yangpath/raw/master/install.sh | sudo bash Alternatively, leverage the system packages or docker images . Export paths # To export the paths from a given YANG module 1 : # assuming cur working dir is the root of openconfig repo yangpath export -m release/models/interfaces/openconfig-interfaces.yang Generate HTML path browser # To create HTML with paths out of template, leverage templating capabilities of yangpath . in this example paths from the Openconfig interfaces module are exported \u21a9","title":"Home"},{"location":"#features","text":"Preserved list keys The exported paths have the list keys present . Knowing the key names makes it very easy to create XPATH/RESTCONF filters targeting a particular node. Readily available for gNMI The exported paths are fully compatible with the gNMI paths, thanks to the keys being present and set to the wildcard * value. RESTCONF-ready With a matter of a single flag value switch yangpath will export the paths in a RESTCONF style . Paste them in Postman and you're good to go! Type information A unique yangpath feature is its ability to provide the type of a given path . Types give additional context when you retrieve the data, but they are of utter importance for edit the configuration operations. Fast Path export with yangpath is quite fast, working with massive models is no longer a problem! User friendly As always, we strive to publish the tools which spark joy, therefore pre-built images with an effortless installation and a beautiful and extensive documentation comes included.","title":"Features"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#install","text":"Use the following installation script to install the latest version. sudo curl -sL https://github.com/hellt/yangpath/raw/master/install.sh | sudo bash Alternatively, leverage the system packages or docker images .","title":"Install"},{"location":"#export-paths","text":"To export the paths from a given YANG module 1 : # assuming cur working dir is the root of openconfig repo yangpath export -m release/models/interfaces/openconfig-interfaces.yang","title":"Export paths"},{"location":"#generate-html-path-browser","text":"To create HTML with paths out of template, leverage templating capabilities of yangpath . in this example paths from the Openconfig interfaces module are exported \u21a9","title":"Generate HTML path browser"},{"location":"about-paths/","text":"Knowing the schema paths (aka schema node identifiers ) are instrumental for any activity involving model-driven management interfaces. Whatever the management task is, a user ends up being in need to either create, read, update or delete data. The YANG modelled data follows a tree-like hierarchy where each node can be uniquely identified with a schema path. Without having a path to a piece of YANG modelled data its impossible to manipulate it, therefore its mandatory to have one. Take a look at this examples where different management interfaces use paths to get different YANG modelled data: gNMI gNMI 1 can use XPATH-like paths to access the YANG modelled data. gnmic -a 10.1.0.11:57400 -u admin -p admin \\ get --path /state/system/platform NETCONF NETCONF uses XPATH filtering or Subtree filtering to access the data. Here is an example of how an XPATH filter can be used within a NETCONF RPC: <rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <get-config> <source> <running/> </source> <!-- get the user named fred --> <filter xmlns:t=\"http://example.com/schema/1.2/config\" type=\"xpath\" select=\"/top/users/user[name='fred']\"/> </get-config> </rpc> RESTCONF RESTCONF embeds the path information in its URI or YANG-PATCH target field. In any case, the path information must be present: GET https://restconf-server:8545/restconf/data/network-device-mgr:network-devices/network-device=192.168.1.11/root/nokia-conf:configure/policy-options/prefix-list=my-prefix-list How to get schema paths? # The schema paths (or YANG paths as we call it here) is not something you can find in a YANG module itself: // tiny YANG module module test3 { yang - version \"1\" ; namespace \"https://hellt/yangpath/test3\" ; prefix \"test3\" ; typedef age { type uint16 { range 1..100 ; } } container c1 { list l1 { key \"key1 key2\" ; leaf key1 { type string ; } leaf key2 { type age ; } leaf leaf1 { type int64 ; } } } } As you see, the path information is not present in the module. But for the given compact and simple module its quite easy to derive the paths by just browsing the contents with a naked eye. We could also you a tree representation of the module to have a better view: pyang -f tree pkg/path/testdata/test3/test3.yang module: test3 +--rw c1 +--rw l1* [key1 key2] +--rw key1 string +--rw key2 age +--rw leaf1? int64 From here, its not that hard to come up with the schema path for these three leafs: /c1/l1/key1 /c1/l1/key2 /c1/l1/leaf1 Unfortunately, this approach is not practical when working with the real-life YANG modules which are of hundred lines of code with multiple cross-references and encapsulations. yangpath mission is to help with this task at hand. It exports the paths from the given YANG module in XPATH or RESTCONF style . \u276f yangpath export -m pkg/path/testdata/test3/test3.yang [rw] /c1/l1[key1=*][key2=*]/key1 string [rw] /c1/l1[key1=*][key2=*]/key2 age [rw] /c1/l1[key1=*][key2=*]/leaf1 int64 Keys in paths # If you noticed, the paths that yangpath provided differ from the ones we extracted ourselves by just looking at the module tree representation. The extra piece here is the list keys that are present in the paths. The reason for the keys to be present is to make paths more universally applicable. When the key information is missing, you loose the granularity of the path. By looking at the path in the /c1/l1/leaf1 form there is no way to tell if the list l1 has keys, and if it does, how many and what are their names? For that reason, yangpath adds keys to the lists, making the paths complete. If the key information is indeed not needed, a user can easily delete the key elements from the path /c1/l1[key1=*][key2=*]/key1 -> /c1/l1/key1 . Path styles # By default yangpath exports paths in XPATH style, but it is also possible to display the paths in a RESTCONF style, all it takes is a single flag switch: \u276f yangpath export -s restconf -m pkg/path/testdata/test3/test3.yang [rw] /c1/l1=key1,key2/key1 string [rw] /c1/l1=key1,key2/key2 age [rw] /c1/l1=key1,key2/leaf1 int64 As with the XPATHs, we try to give you an idea about the keyed lists, by adding key names towards the list elements of the paths. To make this RESTCONF paths to work you need to substitute the key names in the path to the actual values of these keys. In case it is desired to get the list nodes for all keys, just remove the keys from the path: /c1/l1/key1 . Easy! Types # Another addition is the leaf type information. Knowing the type of the YANG node that the path is pointing to is very important. It allows a user to know which values are applicable to that particular YANG node. yangpath does some extra job by expanding the type information for the leafs. If the leaf has the basic YANG type (such as string , int32 , etc) it is displayed as is: YANG type Path type leaf key1 { type string; } string Enumeration # If the leaf is of enumeration type, the values of enumeration will be displayed: YANG type Path type leaf admin-status { type enumeration { enum UP { description \"Ready to pass packets.\"; } enum DOWN { description \"Not ready to pass packets.\"; } enumeration[\"DOWN\" \"UP\"] Leafref # If the leaf is of leafref type, the path the leafref has is displayed: YANG type Path type leaf index { type leafref { path \"../config/index\"; } description \"The index number of the subinterface -- used to address the logical interface\"; } leafref->../config/index Identityref # If the leaf is of identityref type, the referenced identity is displayed: YANG type Path type leaf type { type identityref { base ietf-if:interface-type; } identityref->ietf-if:interface-type Union # If the leaf is of union type, the embedded types are displayed 2 : YANG type Path type type union { type oc-inet:ip-address; type string; } union{oc-inet:ip-address string} examples uses gNMIc CLI client \u21a9 not implemented for leaflists of union type \u21a9","title":"About YANG Paths"},{"location":"about-paths/#how-to-get-schema-paths","text":"The schema paths (or YANG paths as we call it here) is not something you can find in a YANG module itself: // tiny YANG module module test3 { yang - version \"1\" ; namespace \"https://hellt/yangpath/test3\" ; prefix \"test3\" ; typedef age { type uint16 { range 1..100 ; } } container c1 { list l1 { key \"key1 key2\" ; leaf key1 { type string ; } leaf key2 { type age ; } leaf leaf1 { type int64 ; } } } } As you see, the path information is not present in the module. But for the given compact and simple module its quite easy to derive the paths by just browsing the contents with a naked eye. We could also you a tree representation of the module to have a better view: pyang -f tree pkg/path/testdata/test3/test3.yang module: test3 +--rw c1 +--rw l1* [key1 key2] +--rw key1 string +--rw key2 age +--rw leaf1? int64 From here, its not that hard to come up with the schema path for these three leafs: /c1/l1/key1 /c1/l1/key2 /c1/l1/leaf1 Unfortunately, this approach is not practical when working with the real-life YANG modules which are of hundred lines of code with multiple cross-references and encapsulations. yangpath mission is to help with this task at hand. It exports the paths from the given YANG module in XPATH or RESTCONF style . \u276f yangpath export -m pkg/path/testdata/test3/test3.yang [rw] /c1/l1[key1=*][key2=*]/key1 string [rw] /c1/l1[key1=*][key2=*]/key2 age [rw] /c1/l1[key1=*][key2=*]/leaf1 int64","title":"How to get schema paths?"},{"location":"about-paths/#keys-in-paths","text":"If you noticed, the paths that yangpath provided differ from the ones we extracted ourselves by just looking at the module tree representation. The extra piece here is the list keys that are present in the paths. The reason for the keys to be present is to make paths more universally applicable. When the key information is missing, you loose the granularity of the path. By looking at the path in the /c1/l1/leaf1 form there is no way to tell if the list l1 has keys, and if it does, how many and what are their names? For that reason, yangpath adds keys to the lists, making the paths complete. If the key information is indeed not needed, a user can easily delete the key elements from the path /c1/l1[key1=*][key2=*]/key1 -> /c1/l1/key1 .","title":"Keys in paths"},{"location":"about-paths/#path-styles","text":"By default yangpath exports paths in XPATH style, but it is also possible to display the paths in a RESTCONF style, all it takes is a single flag switch: \u276f yangpath export -s restconf -m pkg/path/testdata/test3/test3.yang [rw] /c1/l1=key1,key2/key1 string [rw] /c1/l1=key1,key2/key2 age [rw] /c1/l1=key1,key2/leaf1 int64 As with the XPATHs, we try to give you an idea about the keyed lists, by adding key names towards the list elements of the paths. To make this RESTCONF paths to work you need to substitute the key names in the path to the actual values of these keys. In case it is desired to get the list nodes for all keys, just remove the keys from the path: /c1/l1/key1 . Easy!","title":"Path styles"},{"location":"about-paths/#types","text":"Another addition is the leaf type information. Knowing the type of the YANG node that the path is pointing to is very important. It allows a user to know which values are applicable to that particular YANG node. yangpath does some extra job by expanding the type information for the leafs. If the leaf has the basic YANG type (such as string , int32 , etc) it is displayed as is: YANG type Path type leaf key1 { type string; } string","title":"Types"},{"location":"about-paths/#enumeration","text":"If the leaf is of enumeration type, the values of enumeration will be displayed: YANG type Path type leaf admin-status { type enumeration { enum UP { description \"Ready to pass packets.\"; } enum DOWN { description \"Not ready to pass packets.\"; } enumeration[\"DOWN\" \"UP\"]","title":"Enumeration"},{"location":"about-paths/#leafref","text":"If the leaf is of leafref type, the path the leafref has is displayed: YANG type Path type leaf index { type leafref { path \"../config/index\"; } description \"The index number of the subinterface -- used to address the logical interface\"; } leafref->../config/index","title":"Leafref"},{"location":"about-paths/#identityref","text":"If the leaf is of identityref type, the referenced identity is displayed: YANG type Path type leaf type { type identityref { base ietf-if:interface-type; } identityref->ietf-if:interface-type","title":"Identityref"},{"location":"about-paths/#union","text":"If the leaf is of union type, the embedded types are displayed 2 : YANG type Path type type union { type oc-inet:ip-address; type string; } union{oc-inet:ip-address string} examples uses gNMIc CLI client \u21a9 not implemented for leaflists of union type \u21a9","title":"Union"},{"location":"export/","text":"Exporting YANG schema paths (aka Schema node identifiers) is the prime objective of yangpath . Here we explain how the export command works and demonstrate its options. Required parameters # Right out of the box yangpath is ready to export the paths. The only parameters a user needs to provide are: path to a YANG file from which a user needs to export paths path to a directory with YANG files which are imported by a target module Module to extract paths from # yangpath expects to receive a path to the YANG module from which it needs to extract paths. This is done with the -m | --module flag that takes a relative or absolute path to a file. For example, if we cloned OpenConfig YANG repository and would like to export the paths from its interfaces module we would specify the following path: # current dir ~/openconfig/public yangpath export --module release/models/interfaces/openconfig-interfaces.yang Directory with YANG files # By using -y | --yang-dir flag a user specifies the path to the directory with YANG files which the target module imports. To add multiple directories use the flag several times: yangpath export -y ~/dir1 -y ~/dir2 -y ~/dir3 -m ~/my_module.yang It is not required (though advised for performance reasons) to specify the exact directory with the required modules, its allowed to specify the directory which nests the target directories. Consider the following files hierarchy where the imported modules reside in the directories dir1-3 : . \u251c\u2500\u2500 parent-dir \u251c\u2500\u2500 dir1 \u251c\u2500\u2500 dir2 \u2514\u2500\u2500 dir3 Its possible to tell yangpath to read the parent directory instead of specifying each of the directories separately: yangpath export -y ~/parent-dir -m ~/my_module.yang More details on directories with YANG files When yangpath compiles the YANG module it is about to export paths from, it also needs to compile the modules that the target module imports. Consider the following example of a module that we would like export paths from: module openconfig-interfaces { yang-version \"1\"; // namespace namespace \"http://openconfig.net/yang/interfaces\"; prefix \"oc-if\"; // import some basic types import ietf-interfaces { prefix ietf-if; } import openconfig-yang-types { prefix oc-yang; } import openconfig-types { prefix oc-types; } import openconfig-extensions { prefix oc-ext; } If these imported modules are not in the same directory where the target module is, a user needs to provide a path (or paths) to the directories with these imported modules. Default behavior # With just the above mentioned flags set, the exported paths will be printed to stdout with keys and types fields highlighted: \u276f yangpath export --module release/models/interfaces/openconfig-interfaces.yang [rw] /interfaces/interface[name=*]/config/description string [rw] /interfaces/interface[name=*]/config/enabled boolean [rw] /interfaces/interface[name=*]/config/loopback-mode boolean [rw] /interfaces/interface[name=*]/config/mtu uint16 [rw] /interfaces/interface[name=*]/config/name string [rw] /interfaces/interface[name=*]/config/type identityref->ietf-if:interface-type Paths appear each one on a single line and consist of the following elements: node state: reflects the configuration state of a given node as per 4.2.3 of RFC 7950 . [rw] corresponds for the nodes for which YANG statement config false was not set [ro] corresponds for the nodes for which YANG statement config false was set path: the path itself in a XPATH style with the keys preserved, starting from the root of the module type: YANG type associated with the path in the \"detailed\" form Configuration options # The export command is flexible, it employs some sensible defaults, allowing a user to tailor the output to their needs. All of the configuration options are presented in the embedded help yangpath export --help , here we explain how these option work. Node state # Node state, which is enabled by default and shows if the leaf is a configurable or not, can be turned down with the --node-state=false . Path style # Two path styles are supported by yangpath - XPATH and RESTCONF - the selection is enabled by the [-s | --style] flag. Type style # yangpath augments paths with type information . The --types flag configures the way types are displayed: no : types are not displayed yes : only type names are displayed detailed (default): both type names and enclosed values are displayed as explained here . Color highlighting # Path keys are of prime importance in yangpath export output. To articulate the keys in the schema path we made them highlighted with the ANSI colors. At the same time, the type information is rendered faded so that each element can stay visually separated even if the path is quite long. light theme dark theme If colors are not up to your liking, you can always turn them off by adding a flag --no-color . Node filter # It is possible to display only state or configuration nodes by using --only-nodes flag that takes one of these values: all (default): both configuration and read only nodes are displayed state : only read-only nodes are displayed config : only configuration nodes are displayed Module name # Although module name is likely known to a user, its possible to display the module name along each path by using --with-module yes flag. Format # By default yangpath outputs the paths in text format to stdout, but it can also generate an HTML output which opens the door to some pretty cool usecases which we discuss on the Path Browser page.","title":"Exporting Paths"},{"location":"export/#required-parameters","text":"Right out of the box yangpath is ready to export the paths. The only parameters a user needs to provide are: path to a YANG file from which a user needs to export paths path to a directory with YANG files which are imported by a target module","title":"Required parameters"},{"location":"export/#module-to-extract-paths-from","text":"yangpath expects to receive a path to the YANG module from which it needs to extract paths. This is done with the -m | --module flag that takes a relative or absolute path to a file. For example, if we cloned OpenConfig YANG repository and would like to export the paths from its interfaces module we would specify the following path: # current dir ~/openconfig/public yangpath export --module release/models/interfaces/openconfig-interfaces.yang","title":"Module to extract paths from"},{"location":"export/#directory-with-yang-files","text":"By using -y | --yang-dir flag a user specifies the path to the directory with YANG files which the target module imports. To add multiple directories use the flag several times: yangpath export -y ~/dir1 -y ~/dir2 -y ~/dir3 -m ~/my_module.yang It is not required (though advised for performance reasons) to specify the exact directory with the required modules, its allowed to specify the directory which nests the target directories. Consider the following files hierarchy where the imported modules reside in the directories dir1-3 : . \u251c\u2500\u2500 parent-dir \u251c\u2500\u2500 dir1 \u251c\u2500\u2500 dir2 \u2514\u2500\u2500 dir3 Its possible to tell yangpath to read the parent directory instead of specifying each of the directories separately: yangpath export -y ~/parent-dir -m ~/my_module.yang More details on directories with YANG files When yangpath compiles the YANG module it is about to export paths from, it also needs to compile the modules that the target module imports. Consider the following example of a module that we would like export paths from: module openconfig-interfaces { yang-version \"1\"; // namespace namespace \"http://openconfig.net/yang/interfaces\"; prefix \"oc-if\"; // import some basic types import ietf-interfaces { prefix ietf-if; } import openconfig-yang-types { prefix oc-yang; } import openconfig-types { prefix oc-types; } import openconfig-extensions { prefix oc-ext; } If these imported modules are not in the same directory where the target module is, a user needs to provide a path (or paths) to the directories with these imported modules.","title":"Directory with YANG files"},{"location":"export/#default-behavior","text":"With just the above mentioned flags set, the exported paths will be printed to stdout with keys and types fields highlighted: \u276f yangpath export --module release/models/interfaces/openconfig-interfaces.yang [rw] /interfaces/interface[name=*]/config/description string [rw] /interfaces/interface[name=*]/config/enabled boolean [rw] /interfaces/interface[name=*]/config/loopback-mode boolean [rw] /interfaces/interface[name=*]/config/mtu uint16 [rw] /interfaces/interface[name=*]/config/name string [rw] /interfaces/interface[name=*]/config/type identityref->ietf-if:interface-type Paths appear each one on a single line and consist of the following elements: node state: reflects the configuration state of a given node as per 4.2.3 of RFC 7950 . [rw] corresponds for the nodes for which YANG statement config false was not set [ro] corresponds for the nodes for which YANG statement config false was set path: the path itself in a XPATH style with the keys preserved, starting from the root of the module type: YANG type associated with the path in the \"detailed\" form","title":"Default behavior"},{"location":"export/#configuration-options","text":"The export command is flexible, it employs some sensible defaults, allowing a user to tailor the output to their needs. All of the configuration options are presented in the embedded help yangpath export --help , here we explain how these option work.","title":"Configuration options"},{"location":"export/#node-state","text":"Node state, which is enabled by default and shows if the leaf is a configurable or not, can be turned down with the --node-state=false .","title":"Node state"},{"location":"export/#path-style","text":"Two path styles are supported by yangpath - XPATH and RESTCONF - the selection is enabled by the [-s | --style] flag.","title":"Path style"},{"location":"export/#type-style","text":"yangpath augments paths with type information . The --types flag configures the way types are displayed: no : types are not displayed yes : only type names are displayed detailed (default): both type names and enclosed values are displayed as explained here .","title":"Type style"},{"location":"export/#color-highlighting","text":"Path keys are of prime importance in yangpath export output. To articulate the keys in the schema path we made them highlighted with the ANSI colors. At the same time, the type information is rendered faded so that each element can stay visually separated even if the path is quite long. light theme dark theme If colors are not up to your liking, you can always turn them off by adding a flag --no-color .","title":"Color highlighting"},{"location":"export/#node-filter","text":"It is possible to display only state or configuration nodes by using --only-nodes flag that takes one of these values: all (default): both configuration and read only nodes are displayed state : only read-only nodes are displayed config : only configuration nodes are displayed","title":"Node filter"},{"location":"export/#module-name","text":"Although module name is likely known to a user, its possible to display the module name along each path by using --with-module yes flag.","title":"Module name"},{"location":"export/#format","text":"By default yangpath outputs the paths in text format to stdout, but it can also generate an HTML output which opens the door to some pretty cool usecases which we discuss on the Path Browser page.","title":"Format"},{"location":"html-template/","text":"Outputting paths to a terminal is nice, one can leverage all the *nix tools they have (grep, awk, sed, etc) to filter and modify the exported paths. \u276f yangpath export -y ~/projects/openconfig/public/ \\ -m ~/projects/openconfig/public/release/models/bgp/openconfig-bgp.yang \\ | grep neighbor | grep as-path [rw] /bgp/neighbors/neighbor[neighbor-address=*]/as-path-options/config/allow-own-as uint8 [rw] /bgp/neighbors/neighbor[neighbor-address=*]/as-path-options/config/disable-peer-as-filter boolean [rw] /bgp/neighbors/neighbor[neighbor-address=*]/as-path-options/config/replace-peer-as boolean [ro] /bgp/neighbors/neighbor[neighbor-address=*]/as-path-options/state/allow-own-as uint8 [ro] /bgp/neighbors/neighbor[neighbor-address=*]/as-path-options/state/disable-peer-as-filter boolean [ro] /bgp/neighbors/neighbor[neighbor-address=*]/as-path-options/state/replace-peer-as boolean But we also thought that creating an HTML service for filtering the once exported paths is a nice and powerful idea. So we added an html output format option. HTML templating # With HTML templating its possible to nicely style your paths by creating an HTML file with them. The HTML file then can be served by a server or stored somewhere with shared access. As usual with templates, the logic for the template generation resides within the template itself. For yangpath the template must be done in Go templating syntax, but don't worry, its very easy to create one. Creating a basic HTML template # Lets create an HTML boilerplate that will store our paths in a table format with some bootstrap styling applied. < head > <!-- Font Awesome --> < link rel = \"stylesheet\" href = \"https://use.fontawesome.com/releases/v5.8.2/css/all.css\" > <!-- Google Fonts --> < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap\" > <!-- Bootstrap core CSS --> < link href = \"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css\" rel = \"stylesheet\" > <!-- Material Design Bootstrap --> < link href = \"https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css\" rel = \"stylesheet\" > </ head > < div class = \"container-lg\" > < h1 > yangpath paths </ h1 > < table class = \"table table-striped\" > < thead > < tr > < th > # </ th > < th > Path </ th > < th > Type </ th > </ tr > </ thead > < tbody > < tr > < td > 1 </ td > < td > /c1/l1 </ td > < td > string </ td > </ tr > </ tbody > </ table > </ div > Right now its not a template, but just an HTML page which we populated with static data. Lets make it a template. Path variables # To create a template out of the HTML base we need to embed variables inside the file. By default yangpath passes the list of exported Paths into the templating engine which are accessible via .Paths notation. The Paths list contains Path structures which export the following fields . This means that inside our template we can range over that list and access each of the Path fields. Lets implement this: < div class = \"container-lg\" > < h1 > yangpath paths </ h1 > < table class = \"table table-striped\" > < thead > < tr > < th > # </ th > < th > Path </ th > < th > Type </ th > </ tr > </ thead > < tbody > {{range $i, $p := .Paths}} < tr > < td > {{$i}} </ td > < td > {{$p.XPath}} </ td > < td > {{$p.Type.Name}} </ td > </ tr > {{end}} </ tbody > </ table > </ div > Now lets generate the HTML using this template saved as myTemplate.html : yangpath export -m pkg/path/testdata/test3/test3.yang \\ -f html \\ --template myTemplate.html > paths.html And here we have our paths in the nice looking HTML page: Custom variables # Sometimes you need to augment your template with user-defined variables. For such scenarios we made it possible to pass variables over the CLI in a format of key:::value pairs. Lets say we want to make the header of the table to reflect the original YANG file name from which the paths were exported. To do that we need to pass the value over the CLI with the user-defined key: yangpath export -m pkg/path/testdata/test3/test3.yang \\ -f html \\ --template-vars fname:::pkg/path/testdata/test3/test3.yang \\ --template myTemplate.html > paths.html By now, the variable fname will hold the string value of pkg/path/testdata/test3/test3.yang , which enables us to change the header in our template as follows: < h1 > yangpath paths exported from < code > {{.Vars.fname}} </ code ></ h1 > Here is the result: You can find the final template in the repository . Examples # With the above explained techniques its possible to create a full featured Path Browser which will have filtering capabilities. That is what we did for Nokia SR OS YANG models at hellt/nokia-yangtree .","title":"Generating HTML"},{"location":"html-template/#html-templating","text":"With HTML templating its possible to nicely style your paths by creating an HTML file with them. The HTML file then can be served by a server or stored somewhere with shared access. As usual with templates, the logic for the template generation resides within the template itself. For yangpath the template must be done in Go templating syntax, but don't worry, its very easy to create one.","title":"HTML templating"},{"location":"html-template/#creating-a-basic-html-template","text":"Lets create an HTML boilerplate that will store our paths in a table format with some bootstrap styling applied. < head > <!-- Font Awesome --> < link rel = \"stylesheet\" href = \"https://use.fontawesome.com/releases/v5.8.2/css/all.css\" > <!-- Google Fonts --> < link rel = \"stylesheet\" href = \"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap\" > <!-- Bootstrap core CSS --> < link href = \"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css\" rel = \"stylesheet\" > <!-- Material Design Bootstrap --> < link href = \"https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css\" rel = \"stylesheet\" > </ head > < div class = \"container-lg\" > < h1 > yangpath paths </ h1 > < table class = \"table table-striped\" > < thead > < tr > < th > # </ th > < th > Path </ th > < th > Type </ th > </ tr > </ thead > < tbody > < tr > < td > 1 </ td > < td > /c1/l1 </ td > < td > string </ td > </ tr > </ tbody > </ table > </ div > Right now its not a template, but just an HTML page which we populated with static data. Lets make it a template.","title":"Creating a basic HTML template"},{"location":"html-template/#path-variables","text":"To create a template out of the HTML base we need to embed variables inside the file. By default yangpath passes the list of exported Paths into the templating engine which are accessible via .Paths notation. The Paths list contains Path structures which export the following fields . This means that inside our template we can range over that list and access each of the Path fields. Lets implement this: < div class = \"container-lg\" > < h1 > yangpath paths </ h1 > < table class = \"table table-striped\" > < thead > < tr > < th > # </ th > < th > Path </ th > < th > Type </ th > </ tr > </ thead > < tbody > {{range $i, $p := .Paths}} < tr > < td > {{$i}} </ td > < td > {{$p.XPath}} </ td > < td > {{$p.Type.Name}} </ td > </ tr > {{end}} </ tbody > </ table > </ div > Now lets generate the HTML using this template saved as myTemplate.html : yangpath export -m pkg/path/testdata/test3/test3.yang \\ -f html \\ --template myTemplate.html > paths.html And here we have our paths in the nice looking HTML page:","title":"Path variables"},{"location":"html-template/#custom-variables","text":"Sometimes you need to augment your template with user-defined variables. For such scenarios we made it possible to pass variables over the CLI in a format of key:::value pairs. Lets say we want to make the header of the table to reflect the original YANG file name from which the paths were exported. To do that we need to pass the value over the CLI with the user-defined key: yangpath export -m pkg/path/testdata/test3/test3.yang \\ -f html \\ --template-vars fname:::pkg/path/testdata/test3/test3.yang \\ --template myTemplate.html > paths.html By now, the variable fname will hold the string value of pkg/path/testdata/test3/test3.yang , which enables us to change the header in our template as follows: < h1 > yangpath paths exported from < code > {{.Vars.fname}} </ code ></ h1 > Here is the result: You can find the final template in the repository .","title":"Custom variables"},{"location":"html-template/#examples","text":"With the above explained techniques its possible to create a full featured Path Browser which will have filtering capabilities. That is what we did for Nokia SR OS YANG models at hellt/nokia-yangtree .","title":"Examples"},{"location":"install/","text":"yangpath is a single static binary built for the Linux, Mac OS, Windows platforms and distributed via Github releases . Linux/Mac OS # To download & install the latest release the following automated installation script can be used: sudo curl -sL https://github.com/hellt/yangpath/raw/master/install.sh | sudo bash As a result, the latest yangpath version will be installed in the /usr/local/bin directory and the version information will be printed out. Preparing to install yangpath 0.0.1 into /usr/local/bin yangpath installed into /usr/local/bin/yangpath version : 0.0.1 commit : bdaa6ab date : 2020-08-11T20:27:24Z source : https://github.com/hellt/yangpath docs : https://yangpath.netdevops.me To upgrade run the installation script once again, it will perform the upgrade if a newer version is available. Windows # It is highly recommended to use WSL on Windows, but if its not possible, use releases page to download the windows executable file. Package managers # Links to the Debian and RPM packages are available in the releases section. For example, to install yangpath v0.1.0 with yum issue the following: yum install https://github.com/hellt/yangpath/releases/download/v0.1.0/yangpath_0.1.0-test_linux_x86_64.rpm Docker # The yangpath Docker image is available for each release and is tagged accordignly. You can pull the latest or a specific version: # get the latest version docker pull hellt/yangpath # get a specific release docker pull hellt/yangpath:0.1.0","title":"Installation"},{"location":"install/#linuxmac-os","text":"To download & install the latest release the following automated installation script can be used: sudo curl -sL https://github.com/hellt/yangpath/raw/master/install.sh | sudo bash As a result, the latest yangpath version will be installed in the /usr/local/bin directory and the version information will be printed out. Preparing to install yangpath 0.0.1 into /usr/local/bin yangpath installed into /usr/local/bin/yangpath version : 0.0.1 commit : bdaa6ab date : 2020-08-11T20:27:24Z source : https://github.com/hellt/yangpath docs : https://yangpath.netdevops.me To upgrade run the installation script once again, it will perform the upgrade if a newer version is available.","title":"Linux/Mac OS"},{"location":"install/#windows","text":"It is highly recommended to use WSL on Windows, but if its not possible, use releases page to download the windows executable file.","title":"Windows"},{"location":"install/#package-managers","text":"Links to the Debian and RPM packages are available in the releases section. For example, to install yangpath v0.1.0 with yum issue the following: yum install https://github.com/hellt/yangpath/releases/download/v0.1.0/yangpath_0.1.0-test_linux_x86_64.rpm","title":"Package managers"},{"location":"install/#docker","text":"The yangpath Docker image is available for each release and is tagged accordignly. You can pull the latest or a specific version: # get the latest version docker pull hellt/yangpath # get a specific release docker pull hellt/yangpath:0.1.0","title":"Docker"},{"location":"multi-vendor/","text":"It doesn't matter what color you banners are, yangpath is vendor-agnostic and YANG centric. Simply put, it digests YANG files from multiple vendors with no hiccups. Here we demonstrate how yangpath can be used with models from different vendors and standard organizations. OpenConfig # Likely the most popular vendor-agnostic provider of YANG modules is OpenConfig. Source: openconfig/public # assuming cur working dir is the root of the repo yangpath export -m release/models/interfaces/openconfig-interfaces.yang IETF # The foundational IETF models Source: YangModels/yang # assuming cur working dir is the root of the repo yangpath export -m standard/ietf/RFC/ietf-interfaces@2018-02-20.yang Nokia # By the way, the paths extracted with yangpath are published at hellt/nokia-yangtree . Source: nokia/7x50_YangModels # assuming cur working dir is the root of the repo yangpath export -y YANG -m YANG/nokia-combined/nokia-conf-combined.yang Arista # Arista uses a subset of OpenConfig modules and does not provide IETF modules inside their repo. So make sure you have IETF models somewhere where you can reference it. Source: aristanetworks/yang # assuming cur working dir is the root of the repo # notice the second import where we specify path to the IETF models from OC repo yangpath export -y EOS-4.23.2F/openconfig/public/release/models \\ -y ~/projects/openconfig/public/third_party/ietf/ \\ -m EOS-4.23.2F/openconfig/public/release/models/interfaces/openconfig-interfaces.yang Cisco # Source: YangModels/yang # assuming cur working dir is the root of the repo yangpath export -y standard/ietf/ -m vendor/cisco/xr/711/Cisco-IOS-XR-mpls-ldp-cfg.yang Juniper # Source: Juniper/yang Unfortunately, the underlying library that yangpath uses, have troubles reading the YANG files directories that Juniper has in their repo.","title":"Multivendor examples"},{"location":"multi-vendor/#openconfig","text":"Likely the most popular vendor-agnostic provider of YANG modules is OpenConfig. Source: openconfig/public # assuming cur working dir is the root of the repo yangpath export -m release/models/interfaces/openconfig-interfaces.yang","title":"OpenConfig"},{"location":"multi-vendor/#ietf","text":"The foundational IETF models Source: YangModels/yang # assuming cur working dir is the root of the repo yangpath export -m standard/ietf/RFC/ietf-interfaces@2018-02-20.yang","title":"IETF"},{"location":"multi-vendor/#nokia","text":"By the way, the paths extracted with yangpath are published at hellt/nokia-yangtree . Source: nokia/7x50_YangModels # assuming cur working dir is the root of the repo yangpath export -y YANG -m YANG/nokia-combined/nokia-conf-combined.yang","title":"Nokia"},{"location":"multi-vendor/#arista","text":"Arista uses a subset of OpenConfig modules and does not provide IETF modules inside their repo. So make sure you have IETF models somewhere where you can reference it. Source: aristanetworks/yang # assuming cur working dir is the root of the repo # notice the second import where we specify path to the IETF models from OC repo yangpath export -y EOS-4.23.2F/openconfig/public/release/models \\ -y ~/projects/openconfig/public/third_party/ietf/ \\ -m EOS-4.23.2F/openconfig/public/release/models/interfaces/openconfig-interfaces.yang","title":"Arista"},{"location":"multi-vendor/#cisco","text":"Source: YangModels/yang # assuming cur working dir is the root of the repo yangpath export -y standard/ietf/ -m vendor/cisco/xr/711/Cisco-IOS-XR-mpls-ldp-cfg.yang","title":"Cisco"},{"location":"multi-vendor/#juniper","text":"Source: Juniper/yang Unfortunately, the underlying library that yangpath uses, have troubles reading the YANG files directories that Juniper has in their repo.","title":"Juniper"}]}